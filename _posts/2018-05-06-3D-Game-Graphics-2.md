---
layout: post
title: 3D Game Grahpics - Vertex Processing 
feature-img: "assets/img/sample_feature_img.png"
tags: [GameGraphics]
---

## Chapter2.  정점처리
### 렌더링 파이프 라인 개요

* 먼저 정점처리를 하기 전에 렌더링 파이프 라인에 대하여 간략하게 정리하고 넘어가자
* 렌더링 파이프 라인의 주요 요소
  * 정점처리 (vertex processing) - 래스터화 (rasterization) - 프래그먼트처리(fragment processing) - 출력 변합(output merging)
* 정점처리와 프래그먼트처리는 프로그래밍이 가능한 단계이고, 래스터화와 출력병합 단계는 프로그래밍이 불가능한 하드웨어로 고정된 단계다.
* 프로그래밍이 가능한 단계란 프로그래머가 원하는 방식으로 처리를 할 수 있는 단계이고, 정점셰이더와 프래그먼트셰이더가 그 예다. 
* 프로그래밍이 불가능한 단계는 처리 방식이 고정되어 있고 우리는 처리방식에서 제공하는 파라미터값을  입력하여 작동방식을 설정할 수 있다.
    
 ---------
####  정점처리
* 정점버퍼에 들어있는 모든 정점에 대하여 작동하며, 변환을 비롯한 다양한 정점별 연산을 수행한다.
* 정점에 대한 변환을 비롯한 정점에 대한 연산을 한다.
#### 래스터화 
* 변환된 정점에 대하여 프래그먼트를 생성해준다.
#### 프래그먼트처리
* 픽셀과 프래그먼트의 차이는 없는 것 같지만, 두가지는 다르다. 
* 먼저 프래그먼트란 래스터화에 따른 하나의 데이터 집단이고, 픽셀은 이 프래그먼트들에 대하여 알파블랜딩, z-버퍼링 등의 처리가 끝나고 나온 컬러 버퍼라는 메모리 공간에 저장된 애다.
* 픽셀은 화면의 한 점이라고 생각하면되고 이 픽셀이 되기 전의 데이터들의 집합을 프래그먼트라고 생각하면된다.
* 그래서 프래그먼트에 대한 처리는 텍스쳐링등, 프래그먼트들에 대하여 처리를 해주는 것이다. 
* 자세한 것은 프래그먼트 처리에서 하겠당~
#### 출력병합
* 위에서 말한 픽셀을 만들기 위한 단계가 출력병합 단계다. 알파블랜딩, z-버퍼링등이 출력병합에서 진행된다.

 ---------
### 변환
  
내가 화면에 출력하고자 하는 3D 메쉬 모델이 있고, 이 모델을 월드에 배치 했다고 하자.

모델의 중심의 위치와 회전각도에 따라 각 정점들의 위치를 결정을 해주어야 한다. 

그리고 카메라에서 월드에 배치된 모델을 바라봤을 때 위치도 결정이 되어야 한다. 

그리고 카메라 공간에서 멀리 있는 물체와 가까이있는 물체의 위치를 우리의 눈에 보이는 위치로 변환을 해주어야 한다. 

오브젝트 공간 -> 월드 공간 -> 카메라 공간 -> 클립공간

각 공간사이를 월드 변환, 뷰변환, 투영변환을 통해 변환한다.

--------
### 월드변환
#### 아핀 변환과 동차좌표

* 월드 변환과 뷰변환은 축소 확대, 회전, 이동과 같이 기본적인 변환들을 조합하여 만들어진다. 
* 축소 확대, 회전은 선형변환이라고 하고 이동은 아핀변환이라고 한다.  (아핀변환이 더 큰 집합... 자세히는 밑에 링크를)
  * [선형변환] : <https://ko.wikipedia.org/wiki/%EC%84%A0%ED%98%95_%EB%B3%80%ED%99%98>
  * [아핀변환] : <https://ko.wikipedia.org/wiki/%EC%95%84%ED%95%80_%EB%B3%80%ED%99%98>
* 축소 확대
  * 3차원 공간의 s 만큼 축소 확대 행렬
 > $$ \left[ \begin{matrix} s& 0& 0\\ 0 & s& 0\\ 0& 0& s \end{matrix} \right]$$
* 축에 대한 회전
  * 3차원 공간의 z축을 기준으로 x각도 만큼의 회전
>   $$ \left[ \begin{matrix} cosx& -sinx& 0\\ sinx& cosx& 0\\ 0& 0& 1 \end{matrix} \right]$$
  * 순차 치환을 통해 x축과 y축으로  회전하는 것도 한번 행렬을 만들어 보자. 
* 이동
  * 축소 확대, 회전은 행렬의 곱으로 계산이 가능했다. 이동은 어떻게 하면 가능할까?! 
  * x 축으로 1만큼, y축으로 2만큼 z 축으로 3만큼 이동시키려면?
   * 아래와 같이 행렬의 덧셈으로 표현이 가능하다. (카테시안 좌표계)
>   $$
 \left[ \begin{matrix} x\\ y\\ z \end{matrix} \right]$$ + $$
 \left[ \begin{matrix} d\\ d\\ d \end{matrix} \right]$$ = 
$$ \left[ \begin{matrix} x+d\\ y+d\\ z+d \end{matrix} \right]$$
  * 그러면 행렬의 곱셈으로 표현을 할 수는 없을까? 동차좌표라는 것을 이용하면 행렬의 곱셈형태로 표현을 할 수가 있다.
>   $$ \left[ \begin{matrix} 1& 0& 0& d\\ 0& 1& 0& d\\ 0& 0& 1& d\\ 0& 0& 0& 1 \end{matrix} \right]$$ $$
 \left[ \begin{matrix} x\\ y\\ z\\ 1 \end{matrix} \right]$$ = 
$$ \left[ \begin{matrix} x+d\\ y+d\\ z+d\\ 1 \end{matrix} \right]$$
 
#### 월드 행렬
* 모델을 월드 좌표 $$ \left[ \begin{matrix} x'& y'& z' \end{matrix} \right]$$ 로 이동하려면 위에서 사용했던 이동행렬을 구한다.
* 모델을 s 각도 만큼 회전을 하려면 위에서 구했던 회전 행렬을 구한다. 
* 이동행렬을 T 회전행렬을 R 이라 하고 내 모델의 vertex 좌표를 $$ \left[ \begin{matrix} x& y& z \end{matrix} \right]$$ 라 한다면
> $$ \left[ \begin{matrix} x'\\ y'\\ z' \end{matrix} \right]$$ = TR$$ \left[ \begin{matrix} x\\ y\\ z \end{matrix} \right]$$
* 위와 같이 계산 해주면 된다 여기서 T와 R의 순서가 바뀌면 안된다. 우리는 축을 기준으로 회전을 시켰기 때문에 이동후에 축으로 회전하는 것과 이동전에 회전하는 것은 결과가 아예 다르다. 
#### 오일러 변환
* 하나의 물체를 x,y,z 축을 중심으로 회전하게 되면 물체는 특정한 방향을 가지게 된다. 
* 세축을 중심으로 회전하는 각을 오일러각이라고 하고 이를 한물체의 방향을 표현하는데 쓰인다.
* 세개의 축으로 회전한 것을 결합한것이 오일러 변환이라고 한다. (결한한다는 것은 그냥 곱해주면 되는 거..)
* 오일러 변환에 문제가 있는데 이것은 찾아보거나 나중에 또 나올테니 나중에 애기하도록 하자.
* [오일러각집벌락설명] : <http://hoodymong.tistory.com/3>
* [오일러각] : <https://ko.wikipedia.org/wiki/%EC%98%A4%EC%9D%BC%EB%9F%AC_%EA%B0%81>
#### 노멀 벡터 변환 
* 정점으로 이루어진 폴리곤에는 노멀 벡터가 존재하는데 정점이 월드 좌표로 변환이 된다면 노멀벡터도 월드좌표로 젼환이 되어야 한다.
* 이동만하게 된다면 변환이 필요없게 되겠지만 확대 축소하는 스케일링이나 회전을 하게 되면 노멀벡터의 값도 변환을 해주어야 한다.
* 그러면 정점과 같이 변환하면 되는것 같겠지만, 정점과 같이 변환해주면 안된다. 
* 회전은 정점과 같이 해주면 되지만 비균등 축소확대의 경우에는 스케일링이 문제다.
* **변환행렬 $$M$$을 곱하는 것이 아니라 $$(M^-1)^T $$ 을 해줘야 노멀이 폴리곤과의 수직관계를 유지한다.**

--------
### 뷰변환

이제 월드변환이 끝나서 모델의 정점들을 월드공간의 좌표로 바꿨다면 이제 카메라 공간의 좌표로 변환을 해주어야 한다.

#### 카메라 공간
카메라 는 **EYE, AT, UP** 세가지 파라미터를 가진다. 

* **EYE**는 월드 공간에서 카메라의 위치를 말한다. 
* **AT**은 월드 공간에서 카메라가 바라보는 기준점이다. 
* **UP**은 카메라의 상단이 가리키는 방향의 벡터이다. 일반적으로 y축이다.

*3차원 공간을 기저(basis)와 원점으로 정의한다. 기저란, 공간을 구성하기 위한 정의 정도로 보면 될듯하다.*

카메라 공간의 기저를 {u,v,n} 으로 표기하자. 카메라의 세가지 파라미터를 가지고 카메라공간의 기저를 구하자.
* **AT**과 **EYE**를 이은 벡터를 정규화하여 단위벡터 n을 구한다.
* **UP**과 n을 외적하여 벡터를 얻고 그 벡터를 정규화해서 단위벡터 u를 구한다.
* n과 u를 외적하여 단위벡터 v를 구한다.
카메라 공간의 원점을 정하고, 기저와 원점으로 카메라 공간을 정의해보자.
* **EYE**를 카메라 공간의 원점으로 한다.
* 카메라 공간은 {**EYE**, u, v, n} 으로 표기한다.

#### 공간이전과 뷰행렬 

월드 공간좌표를 카메라 공간좌표로 이동시킬 것이다. 
뷰변환을 위해서는 하나의 공간에서 다른 공간으로 옮기는 **공간이전**을 할 것이다. 

* 월드 공간을 {(0,0,0),(1,0,0),(0,1,0),(0,0,1)} 
* 카메라 공간을 {**EYE**, u, v, n} 
* 월드공간에서 카메라 공간으로 이동시키기 위해 해야 할 일은, 이동과 회전이다.  
* 이동행렬과 회전행렬을 구해 결합하면 월드공간에서 카메라 공간으로 변환하는 행렬을 구한 것이다. 
* 먼저 이동행렬은 T 는 **EYE**을 원점으로 옮기면 되는 것이니 아래와 같다.
> $$ T = \left[ \begin{matrix} -EYEx\\ -EYEy\\ -EYEz \end{matrix} \right]$$
* 회전행렬은 각도를 가지고 계산하는 것이 맞지만, 사실 각도를 가지고 계산할 필요없이 회전행렬 R은 아래와 같이 구하면 된다.
  * R*(1, 0, 0) = u, R*(0, 1, 0) = v, R*(0, 0, 1) = n 이므로 이를 행렬로 만든다.
  * R의 역행렬을 양변에 곱해준다.
> $$ R \left[ \begin{matrix} u& v& n \end{matrix} \right] =  
\left[ \begin{matrix} 1& 0& 0\\ 0& 1& 0\\ 0& 0& 1 \end{matrix} \right]
 ,  \left[ \begin{matrix} u& v& n \end{matrix} \right] = (R^-1) $$
   * 양 변에 가로 열에 각각 u,v,n을 배치한 행렬을 곱해준다.
>  $$ \left[ \begin{matrix} u\\ v\\ n \end{matrix} \right] 
 \left[ \begin{matrix} u& v& n \end{matrix} \right] = \left[ \begin{matrix} u\\ v\\ n \end{matrix} \right](R^-1) $$
   * 단윈벡터 이므로 $$ u \cdot u = 1 $$
   * u, v, n은 서로 직교 하므로 $$ u \cdot v = 0, v \cdot n = 0, n \cdot u = 0 $$
> $$ \left[ \begin{matrix} 1& 0& 0\\ 0& 1& 0\\ 0& 0& 1 \end{matrix} \right] =
 \left[ \begin{matrix} u\\ v\\ n \end{matrix} \right](R^-1)  $$
   * 양변에 R을 곱해서 회전행렬 R을 얻는다.
> $$ R = \left[ \begin{matrix} u\\ v\\ n \end{matrix} \right] $
$
* 이제 이동 행렬 T를 동차좌표로 변환해서 행렬 R과 결합하면 된다. 순서는 이동후 회전을 해주어야 하니, 결합행렬은 RT이다.

--------
### 정점별 조명

* 광원에서 나온 빛의 벡터와 정점과 카메라 를 잇는 벡터의 사이 각도가 작을 수록 빛의 세기가 밝아진다. 
* 위와 같은 이론?을 기반으로 정점별로 조명을 계산하므로 이를 정점별 조명이라고 하고 책의 5장에 더 자세히 나와있으므로 또 공부하면서 정리하도록한다.

----------
### 투영변환

이제 물체를 카메라 공간으로 가져 왔으므로 우리가 보는 화면의 위치로 변환을 시켜야 한다.
이를 투영변환이라고 하며 이제 그 투영변환이 무엇인지 알아보자.

#### 뷰프러스텀 

* 카메라의 시야가 정해져 있어 3차원 공간에 다양한 물체가 있더라도 카메라 시야에 들어오는 물체들만이 나의 뷰에 그려질 것이다.
* ... 그림을 나중에 추가 하고 설명을 추가 하도록 한다. 
* 뷰프러스텀이란 시야각과 카메라로 부터 볼 수 있는 최대 거리와 최소거리로 이루어진 유한한 영역을 말한다.
  * fovy는 카메라의 상단인 y축을 따른 시야각을 말한다. (field of view) 
  * aspect는 뷰볼륨의 종횡비를 나타낸다. (가로세로 비율)
  * n은 카메라로 부터 볼 수 있는 최소한의 거리에 있는 평면인 전방 평면까지의 거리를 가르킨다.
  * f는 카메라로 부터 볼 수 있는 최대한의 거리에 있는 평면인 후방평면의 거리 가르킨다.
  * 카메라로 부터의 전방평면과 후방평면의 좌표는  -n, -f이 되겠다. 카메라가 바라보는 방향이 -를 가르키므로.
* 뷰프러스텀으로 부터 안보이는 영역은 최종화면에 나타나지 않기 때문에 GPU 파이프라인에 들어가지 못하도록 해야 하는데 이를 골라내는 작업을 뷰프러스텀 컬링이라고 한다.
  * 이를 위해서는 메쉬에 대한 바운딩 볼륨을 만들어서 계산을 해주어야 하는데 이 계산이 쉽기 때문에 CPU에서 GPU 호출전에 미리 검사해준다.
  * 뷰프러스텀은 평면이기 때문에 이와 구의 교차 검사와 내부 외부 검사를 해주는 것은 매우 간단하다.
  * 약간의 CPU 비용을 통해 상당한 GPU 계산 비용을 절감한다. 
* 모델과 뷰프러스텀이 교차하게 되어 부분만 안보이게 된다면 이부분에 대한 처리도 필요한데 이것을 클리핑이라고 한다. 
  * 클리핑은 카메라 공간에서 클립공간으로 변환된 후 수행이 되어야 한다. 
  
#### 투영 행렬

뷰프러스텀이 무엇인지 대강 살펴 봤으니, 우리가 하려는 투영행렬이 무엇을 하는 것이고 투영행렬은 어떻게 구하는지 살펴보도록 하자.

* 투영 공간으로 변환하는 것은 피라미드 모양으로 생긴 뷰프러스텀 공간을 2X2X1 크기의 직육면체 공간으로 변환하는 것이다.
  * 이렇게 변환하게 되면 멀리있는 물체는 더 작아보일 것이고 가까운 물체는 멀리있는 물체보다는 크게 보일 것이다. 
* 투영행렬은 다음과 같다. 
> $$ \left[ \begin{matrix} 
\frac{ \cot ( \frac{fovy}{2} )}{aspect} & 0& 0& 0\\ 
0& \cot ( \frac{fovy}{2} ) & 0& 0\\ 
0& 0& \frac{f}{f-n}& \frac{nf}{f-n}\\ 
0& 0& -1& 0 
\end{matrix} \right] $$

 이제 투영행렬을 투영변환 된 값이 래스터화 단계로 들어갈 것이다. 
 하지만 레스터화 단계에서는 왼손좌표계를 사용하기 때문에 오른손좌표계에서 왼손좌표계로 변환을 해주는 작업을 해야 한다.
 
* x, y 좌표는 변화가 없지만, Z축의 범위가 [-1, 0]에서 [1, 0]으로 바뀔 것이다. 
* 좌표계 변환까지 적용한 변환 행렬은 다음과 같다. 
> $$ \left[ \begin{matrix} 
\frac{ \cot ( \frac{fovy}{2} )}{aspect} & 0& 0& 0\\ 
0& \cot ( \frac{fovy}{2} ) & 0& 0\\ 
0& 0& -\frac{f}{f-n}& -\frac{nf}{f-n}\\ 
0& 0& -1& 0 
\end{matrix} \right] $$



---------
[게임 프로그래밍을 위한 3차원 게임그래픽스 - 한정현] 참고 
 
 중간 중간 빈 유도 과정은 다음에 올려보도록 ... ㅎㅎ
 